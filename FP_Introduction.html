<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>FP_Introduction</title>
  </head>
  <body>
    <script>
      // Pure Function
      const add = (a, b) => a + b;

      console.log(add(1, 2));
      console.log(add(1, 2));
      console.log(add(1, 2));

      // Pure Function
      const c = 2; // c is not likely to change during programming.
      const add2 = (a, b) => a + b + c;

      // No Pure Function
      let d = 2; // d is likely to change during programming.
      const add3 = (a, b) => a + b + d;

      console.log(add3(10, 2)); // 14
      console.log(add3(10, 3));
      console.log(add3(10, 4));
      d = 10;
      console.log(add3(10, 2)); // 22
      console.log(add3(10, 3));
      console.log(add3(10, 4));
      // => timing is important, but FP is not.

      // No Pure Function
      let e = 10;
      const add4 = (a, b) => {
        e = b;
        return a + b;
      };

      console.log("e:", e); // 10
      console.log(add4(1, 2));
      console.log("e:", e); // 2

      // No Pure Function
      let obj1 = { value: 10 };
      const add5 = (obj, b) => {
        obj.value += b; // obj.value = obj.value + b
      };

      console.log(obj1.value);
      add5(obj1, 4);
      console.log(obj1.value);

      // Pure Function again!
      // In FP, referred to only, not change initialized value.
      const obj2 = { value: 10 };
      const add6 = (obj, b) => {
        return { value: obj.value + b };
      };

      console.log(obj2);
      const obj3 = add6(obj2, 10);
      console.log(obj3);
      console.log(obj2);

      // First-class Object
      // 1. 함수를 언어에서 값으로 다룰 수 있다.
      // 2. 런타임에서 언제나 정의할 수 있다.
      // 3, 함수를 언제나, 시점에 상관없이 들고 다닐 수 있다.
      // 4. 언제나 인자로 보낼 수 있다.
      // 5. 내가 원하는 시점에서 들고다니다가 평가할 수 있다.
    </script>
  </body>
</html>
